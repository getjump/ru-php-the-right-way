---
isChild: true
---

## Фильтрация данных {#data_filtering_title}

Никогда не доверяйте пользовательскому вводу, который передается вашему PHP коду. Всегда проверяйте и очищайте пользователский ввод перед его использованием в коде. Функции `filter_var` и `filter_input` помогут очистить переменные, а также проверить соответствие введенных данных некоторому формату (например адрес электронной почты).

Пользовательский ввод может быть различным: `$_GET` и `$_POST`, данные введенные в форму, некоторые значения в суперглобальной переменной `$_SERVER` и тело HTTP запроса открытое с помощью `fopen('php://input`, 'r')`. Запомните, что пользовательский ввод не ограничивается данными формы, отправленной пользователем. Отправляемые и загружаемые файлы, значения сессий, данные cookie и данные сторонних веб-сервисов также приравниваются к пользовательскому вводу.

Хотя пользовательские данные могут быть без проблем сохранены, скомбинированы и к ним может быть получен доступ позже, они всё ёще является пользовательским вводом. Каждый раз, когда вы что-либо обрабатываете, объединяете или подключаете данные в ваш код, спросите себя, отфильтрованы ли эти данные и можно ли им доверять.

Данные могут быть _отфильтрованы_ по-разному, в зависимости от их назначения. Например, когда нефильтрованные данные, введенные пользоватем, передаются в HTML код страницы, он может выполнить HTML и JavaScript на вашем сайте! Этот тип атаки известен, как Cross-Site-Scripting (XSS) и может иметь очень серьзные последствия. Один из способов избежать XSS заключается в очистке ввода от всех HTML тэгов (их удалением, или заменой на HTML символы) с помощью функции `strip_tags` или экранирование символов в равносильные им HTML сущности с функцией `htmlentities` или `htmlspecialchars`.

Другой пример, передача данных для выполнения командной строкой. Это может быть крайне опасно (и, как правило &mdash; это плохая идея), но вы можете использовать встроенную функцию `escapeshellarg` для очистки аргументов командной строки.

Последний пример, принимает пользовательский ввод, чтобы определить, какой файл загружать из файловой системы.  Это может быть использовано, для изменения имени файла, на путь файла. Вам нужно убрать "/", "../", [нулевые байты][6] или другие символы из пути файла, так чтобы скрипт не мог загружать скрытые, не-публичные или конфиденциальные файлы.

* [Подробнее о фильтрации данных][1]
* [Подробнее о функции `filter_var`][4]
* [Подробнее о функции `filter_input`][5]
* [Подробнее о обработке нулевых байтов][6]

### Санитизация

Санитизация удаляет (или экранирует) неправильные или небезопасные символы из пользовательского ввода.

Например, вам необходимо нормализовать пользовательский ввод перед подключением ввода в HTML или 
его вставкой в сырой SQL запрос. Когда вы используете связанные параметры с [PDO](#databases), 
они будут очищать ввод за вас.

Иногда требуется разрешить некоторые безопасные HTML тэги в вводе, когда он подключается в HTML 
страницу. Это очень трудно сделать и многие избегают этого, используя ограниченное форматирование, 
как например Markdown или BBCode, либо библиотеки с белым списком, как [HTML Purifier][html-purifier] 
существующие по этой причине.

[Санитизационные фильтры][2]

### Валидация

Валидация гарантирует, что пользовательский ввод, является тем, что вы ожидаете. Например, вы 
можете валидировать : адрес электронной почты, номер телефона или возраст при обработке запроса 
регистрации.

[Валидационные фильтры][3]

[1]: http://www.php.net/manual/ru/book.filter.php
[2]: http://www.php.net/manual/ru/filter.filters.sanitize.php
[3]: http://www.php.net/manual/ru/filter.filters.validate.php
[4]: http://php.net/manual/ru/function.filter-var.php
[5]: http://www.php.net/manual/ru/function.filter-input.php
[6]: http://php.net/manual/ru/security.filesystem.nullbytes.php
[html-purifier]: http://htmlpurifier.org/
