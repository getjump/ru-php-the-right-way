---
layout: page
title: Функциональное программирование в PHP
---

# Функциональное программирование в PHP

PHP поддерживает перво-классные функции, это значит, что функция может быть применена к переменной. И определенные 
пользователем, и встроенные функции могут быть применены к переменной и вызываться динамически. Функции могут быть 
переданы, как аргумент к другой функции (эта особенность называется функцией высшего порядка), а так-же функция 
может возвращать другую функцию.

Рекурсия, особенность, которая позволяет функции вызывать саму себя, это поддерживается языком, но большая часть кода 
PHP фокусируется на итерации.

Новые анонимные функции(с поддержкой для замыканий) присутствую с PHP 5.3 (2009).

В PHP 5.4 добавлена возможность связывать замыкание с областью видимости объекта, а так-же улучшена поддержка 
callables(всё что может быть вызвано), так что они могут быть использованы наравне с анонимными функциями практически 
во всех случаях.

Наиболее распространным использованием функций высшего порядка, является реализация паттерна стратегия. Встроенная 
функция `array_filter` спрашивает одинаково, как входной массив(данные), так и функцию (стратегия или callback), 
используемая, как фильтр для каждого элемента массива.

{% highlight php %}
<?php
$input = array(1, 2, 3, 4, 5, 6);

// Создает новую анонимную функцию и присваевает её к переменной
$filter_even = function($item) {
    return ($item % 2) == 0;
};

// Встроенная функция принимает, как массив, так и функцию
$output = array_filter($input, $filter_even);

// Функции не обязательно нужно быть присвоенной к переменной. Это так-же работает:
$output = array_filter($input, function($item) {
    return ($item % 2) == 0;
});

print_r($output);
{% endhighlight %}

Замыкания - это анонимные функции, которые могут получить доступ к переменные, импортированным извне области видимости, 
без использования любых глобальных переменных. Теоретически, замыкание - функция с закрытыми некоторыми аргументами
(например фиксированными) окружением, когда они объявлены. Замыкания могут обойти ограничения области видимости 
переменных, чистым способом.

В следующем примере, мы используем замыкания для объявления функции, возвращающей одну функцию фильтр для `array_filter` 
из семьи фильтрирующих функций.

{% highlight php %}
<?php
/**
 * Создает анонимную функцию фильтр позволяющую значение > $min
 *
 * Возвращает один фильтр типа "больше чем n".
 */
function criteria_greater_than($min)
{
    return function($item) use ($min) {
        return $item > $min;
    };
}

$input = array(1, 2, 3, 4, 5, 6);

// Используем array_filter на вводе, с указанной функцией фильтром
$output = array_filter($input, criteria_greater_than(3));

print_r($output); // значения > 3
{% endhighlight %}

Каждая функция фильтр в семье, принимает только те элементы, значение которых больше, определенного минимального 
значения. Одиночный фильтр возвращается с помощью замыкания `criteria_greater_than` с аргументом `$min` с  
закрытым значением в области видимости (даётся, как аргумент, когда `criteria_greater_than` вызывается).

Ранее связывание, используется по умолчания, для импортирования переменной `$min` для передачи переменной в созданную 
функцию. Для настоящих замыканий с поздним связыванием обязательно следует использовать ссылку при импортировании. 
Представьте себе библиотеки шаблонизации или валидации ввода, где замыкания объявлены для захвата переменных в 
области видимости и доступа к ним позже, когда анонимные функции исполняются.

* [Подробнее об Анонимных функцих][anonymous-functions]
* [Больше деталей в Closures RFC][closures-rfc]
* [Узнать о динамически вызываемых функция с `call_user_func_array`][call-user-func-array]

[anonymous-functions]: http://www.php.net/manual/ru/functions.anonymous.php
[call-user-func-array]: http://php.net/manual/ru/function.call-user-func-array.php
[closures-rfc]: https://wiki.php.net/rfc/closures
