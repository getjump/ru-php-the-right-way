---
layout: page
title: Основы
---

# Основы

## Операторы сравнения

Операторы сравнения часто упускается из виду аспект PHP, который может привести ко многим неожиданным результатам.
Одна из таких проблем возникает из-за строгого сравнения (сравнение логических значений в виде целых чисел).

{% highlight php %}
<?php
$a = 5;   // 5 как целое число (integer)

var_dump($a == 5);       // Сравниваются значения; Вернёт true
var_dump($a == '5');     // Сравниваются значения (игнорируя типы); Вернёт true
var_dump($a === 5);      // Сравниваются типы и значения (integer vs. integer); Вернёт true
var_dump($a === '5');    // Сравниваются типы и значения (integer vs. string); Вернёт false

/**
 * Строгое сравнение
 */
if (strpos('testing', 'test')) {    // 'test' находится в 0 позиции, результатом будет 'false'
    // Ваш код...
}

vs.

if (strpos('testing', 'test') !== false) {    // Результатом будет 'true', т.к. тут строгое сравнение (0 !== false)
    // Ваш код...
}
{% endhighlight %}

* [Операторы сравнения](http://php.net/manual/ru/language.operators.comparison.php)
* [Таблица сравнения типов](http://php.net/manual/ru/types.comparisons.php)

## Условные операторы

### Оператор "If"

При использовании операторов 'if/else' внутри функции или класса, существует распространенное заблуждение, что 'else'
должен быть использован при возврате результатов выполнения. Если условие не выполняется и при этом возвращается 
значение (return $value), то использование 'else' может быть спорным.

{% highlight php %}
<?php
function test($a)
{
    if ($a) {
        return true;
    } else {
        return false;
    }
}

vs.

function test($a)
{
    if ($a) {
        return true;
    }
    return false;    // else использовать не обязательно
}
{% endhighlight %}

* [Оператор "If"](http://php.net/manual/ru/control-structures.if.php)

### Оператор "Switch"

Оператор "Switch" является отличным способом, чтобы не использовать много операторов "if" с использованием "elseif",
но необходимо знать некоторые вещи:

- Оператор "Switch" сравнивает только значения, но не типы данных (равнозначно логической операции '==')
- Этот оператор сравнивает выражение с каждым значением, пока не найдёт нужное. Если не нашёл, использует 
"default" (если определён)
- Без использования 'break', выражение будет сравниваться со всеми значениями по-порядку, пока не встретит "break" 
или "return"
- Если вы используете для возврата результата 'return' то 'break' можно опустить.

{% highlight php %}
<?php
$answer = test(2);    // Этот код выберет 'case 2' и 'case 3'.

function test($a)
{
    switch ($a) {
        case 1:
            // Код...
            break;             // Прекратит выполнение switch тут если $a == 1, т.к. используется 'break'
        case 2:
            // Код...         // Код без 'break', поэтому будет выполнено сравнение с 'case 3'
        case 3:
            // Код...
            return $result;    // within a function, 'return' will end the function
        default:
            // Код...
            return $error;
    }
}
{% endhighlight %}

* [Оператор Switch](http://php.net/manual/ru/control-structures.switch.php)
* [PHP switch](http://phpswitch.com/)

## Глобальное пространство имён

Когда вы используете пространство имён (namespaces), вы можете обнаружить, что некоторые функции вам скрыты, недоступны.
Что исправить это, указываете что это глобальная функция, использовав обратную косую черту '/' перед именем функции.

{% highlight php %}
<?php
namespace phptherightway;

function fopen()
{
    $file = \fopen();    // Функция имеет имя такое же как и глобальная функция 'fopen'.
                         // Чтобы их различать используйте в глобальных '\'.
}

function array()
{
    $iterator = new \ArrayIterator();   // ArrayIterator внешний класс. Если использовать его без '/'
                                        // то интерпретатор PHP будет пытаться найти его в пространстве 'phptherightway'.
}
{% endhighlight %}

* [Глобальное пространство имён](http://php.net/manual/ru/language.namespaces.global.php)
* [Правила именования](http://php.net/manual/ru/userlandnaming.rules.php)

## Строки

### Конкатенация (сцепление)

- Если ваша строка на одной строке занимает не рекомендуемую длину  (120 символов), используйте конкатенацию.
- Для удобства чтения лучше использовать конкатенацию, чем операторы присваивания.
- Если используете новую строку при сцеплении строк, делайте относительно оригинальной строки отступы.

{% highlight php %}
<?php
$a  = 'Multi-line example';    // Оператор сцепления строк (.=)
$a .= "\n";
$a .= 'of what not to do';

vs.

$a = 'Multi-line example'      // Оператор объединения (.)
    . "\n"                     // используя новые строки.
    . 'of what to do';
{% endhighlight %}

* [Операторы для строк](http://php.net/manual/ru/language.operators.string.php)

### Тип строки.

Строки постоянный спутник для сообщества PHP, надеемся, эта статья объяснит различия между строковыми
типами и их преимущества/использование.

#### Одиночные кавычки

Часто самый быстрый способ отделить строку - эта использовать одинарные кавычки. Скорость заключается в том, что
PHP не анализирует строку (не ищет в ней переменные). Одинарные кавычки лучше всего подходят для:

- строк, которые не нужно анализировать,
- имён переменных, которые нужно написать как текст.

{% highlight php %}
<?php
echo 'Посмотрите как прекрасна моя симпатичная строка.';    // анализ этой строке не нужен.

/**
 * Выведет:
 *
 * Посмотрите как прекрасна моя симпотичная строка.
 */
{% endhighlight %}

* [Одиночные ковычки](http://www.php.net/manual/ru/language.types.string.php#language.types.string.syntax.single)

#### Двойные кавычки

Двойные кавычки, как швейцарский нож. Они лучше всего используются для:

- Escaped strings
- строк с использованием переменных, 
- использования Condensing multi-line concatenation, для удобство просмотра кода.

{% highlight php %}
<?php
echo 'phptherightway is ' . $adjective . '.'     // эта строка использует multiple concatenating для
    . "\n"                                       // отделения переменных от строки.
    . 'I love learning' . $code . '!';

vs.

echo "phptherightway is $adjective.\n I love learning $code!"  // А тут используются двойные кавычки.
{% endhighlight %}

При использовании двойных кавычки часто бывает, что переменную нужно использовать в чуть изменнёном виде.
Но при анализе строки PHP не сможет определить что это переменная. Для решения этой проблемы, оберните переменную
в фигурные скобки.

{% highlight php %}
<?php
$juice = 'plum';
echo "I drank some juice made of $juices";    // $juices не определена

vs.

$juice = 'plum';
echo "I drank some juice made of {$juice}s";    // $juice будет анализирована.

/**
 * Комплексные переменные также оборачивайте в фигурные скобки.
 */

$juice = array('apple', 'orange', 'plum');
echo "I drank some juice made of {$juice[1]}s";   // $juice[1] будет анализирована.
{% endhighlight %}

* [Двойные кавычки](http://www.php.net/manual/ru/language.types.string.php#language.types.string.syntax.double)

#### Nowdoc синтаксис

Nowdoc синтаксис был введён в php 5.3 и используется также как и одинарные кавычки, только для использования нескольких
строк не нужно использовать объединение.

{% highlight php %}
<?php
$str = <<<'EOD'             // Инициализируется <<<
Example of string
spanning multiple lines
using nowdoc syntax.
$a does not parse.
EOD;                        // закрывается 'EOD' (должен быть на новой строке и без отступов).

/**
 * Вывод:
 *
 * Example of string
 * spanning multiple lines
 * using nowdoc syntax.
 * $a does not parse.
 */
{% endhighlight %}

* [Nowdoc](http://www.php.net/manual/ru/language.types.string.php#language.types.string.syntax.nowdoc)

#### Heredoc синтаксис

Heredoc синтаксис работает также как и двойные кавычки, но также для использования нескольких строк не 
нужно использовать объединение.

{% highlight php %}
<?php
$a = 'Variables';

$str = <<<EOD               // Инициализируется <<<
Example of string
spanning multiple lines
using heredoc syntax.
$a are parsed.
EOD;                        // закрывается  'EOD' (должен быть на новой строке и без отступов).

/**
 * Вывод:
 *
 * Example of string
 * spanning multiple lines
 * using heredoc syntax.
 * Variables are parsed.
 */
{% endhighlight %}

* [Heredoc](http://www.php.net/manual/ru/language.types.string.php#language.types.string.syntax.heredoc)

## Тернарный оператор

Тернарный оператор ('(expr1) ? (expr2) : (expr3)') используется для удобства объединения кода в одну строку, но часто избыточен. Хоть он может
быть вложенным, рекомендуется его использовать один на строку.
{% highlight php %}
<?php
$a = 5;
echo ($a == 5) ? 'yay' : 'nay';

vs.

//Вложения
$b = 10;
echo ($a) ? ($a == 5) ? 'yay' : 'nay' : ($b == 10) ? 'excessive' : ':(';    // Вложения трудно читаемы.
{% endhighlight %}

Используя 'return' будьте внимательны:.

{% highlight php %}
<?php
$a = 5;
echo ($a == 5) ? return true : return false;    // этот пример будет выдавать сообщение об ошибке

vs.

$a = 5;
return ($a == 5) ? 'yay' : 'nope';    // этот пример вернёт 'yay'
{% endhighlight %}

* [Тернарный оператор](http://php.net/manual/ru/language.operators.comparison.php)

## Объявление переменных

Время от времени разработчики пытаются сделать свой код "чище" использую предопределённые переменные.
Обычно это только ведёт к увеличению используемой памяти. Для примера сообщите какой-нибудь переменной строку размером
1мб, в результате вы скопируете это дважды.

{% highlight php %}
<?php
$about = 'Очень большой текст';    // будет использоваться 2MB памяти
echo $about;

vs.

echo 'Очень большой текст';        // а тут всего лишь 1MB
{% endhighlight %}

* [Советы по оптимизации (en)](https://developers.google.com/speed/articles/optimizing-php)
