---
layout: page
title: Design Patterns
---

# Шаблоны проектирования

Есть множество способов структурировать и проектировать код веб приложения и вы можете приложить максимум усилий 
или немного подумать, чтобы понять какая вам нравиться архитектура. В любом случае это хорошая идея использовать общие
шаблоны проектирования, потому что это делает код для других более понятным и легко используемым.

* [Архитектура программного обеспечения на Википедии](https://ru.wikipedia.org/wiki/%D0%90%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE_%D0%BE%D0%B1%D0%B5%D1%81%D0%BF%D0%B5%D1%87%D0%B5%D0%BD%D0%B8%D1%8F)
* [Шаблон проектирования на Википедии](https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)

## Фабрика (англ. Factory)

Этот шаблон является одним из часто используемых. В нём класс просто создаёт объект, который вам необходим.
Рассмотрим следующий пример шаблон фабрики:

{% highlight php %}
<?php
class Automobile
{
    private $vehicle_make;
    private $vehicle_model;

    public function __construct($make, $model)
    {
        $this->vehicle_make = $make;
        $this->vehicle_model = $model;
    }

    public function get_make_and_model()
    {
        return $this->vehicle_make . ' ' . $this->vehicle_model;
    }
}

class AutomobileFactory
{
    public static function create($make, $model)
    {
        return new Automobile($make, $model);
    }
}

// фабрика создаёт автомобильные объекты
$veyron = AutomobileFactory::create('Bugatti', 'Veyron');

print_r($veyron->get_make_and_model()); // выведет "Bugatti Veyron"
{% endhighlight %}

Этот код создаст объект "Автомобиль", используя фабрику. Сделав так вы получите два преимущества: во-первых,
если вам в дальнейшем нужно изменить, переименовать или заменить класс Automobile, то вы легко это сделаете, просто
изменив код в фабрике AutomobileFactory, вместо того, чтобы менять его во всех местах проекта, которые используют класс
Automobile; во-вторых, если вам нужно при создании объекта выполнять какие-то операции с этим объектом, то вы можете 
описать эти операции в фабрике, вместо того чтобы каждый раз их описывать при создании нового объекта.

Использовать шаблон Фабрика не всегда необходимо (или слишком мудро). В примере, что выше код настолько прост, что 
использование фабрики добавляет не нужную сложность. Однако если вы делаете довольно большой и сложный проект, то
использование шаблона Фабрика позволит вам избежать многих хлопот.

* [Фабрика на Википедии](https://ru.wikipedia.org/wiki/%D0%A4%D0%B0%D0%B1%D1%80%D0%B8%D1%87%D0%BD%D1%8B%D0%B9_%D0%BC%D0%B5%D1%82%D0%BE%D0%B4_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)

## Одиночка (англ. Singleton)

При создании веб приложения, часто требуется концептуально и архитектурно предоставить доступ только к одному 
экземпляру определённого класса. Шаблон Одиночка позволяет это сделать.

{% highlight php %}
<?php
class Singleton
{
    /**
     * @var Singleton The reference to *Singleton* instance of this class
     */
    protected static $instance;
    
    /**
     * Returns the *Singleton* instance of this class.
     *
     * @return Singleton The *Singleton* instance.
     */
    public static function getInstance()
    {
        if (null === static::$instance) {
            static::$instance = new static();
        }

        return static::$instance;
    }

    /**
     * Protected constructor to prevent creating a new instance of the
     * *Singleton* via the `new` operator from outside of this class.
     */
    protected function __construct()
    {
    }

    /**
     * Private clone method to prevent cloning of the instance of the
     * *Singleton* instance.
     *
     * @return void
     */
    private function __clone()
    {
    }

    /**
     * Private unserialize method to prevent unserializing of the *Singleton*
     * instance.
     *
     * @return void
     */
    private function __wakeup()
    {
    }
}

class SingletonChild extends Singleton
{
}

$obj = Singleton::getInstance();
\var_dump($obj === Singleton::getInstance());             // bool(true)

$anotherObj = SingletonChild::getInstance();
\var_dump($anotherObj === Singleton::getInstance());      // bool(false)

\var_dump($anotherObj === SingletonChild::getInstance()); // bool(true)
{% endhighlight %}


Этот код реализует данный шаблон, используя [*статические* переменные](http://php.net/language.variables.scope#language.variables.scope.static)
и статический метод `getInstance()`.
Обратите внимание на следующее:

* Конструктор [`__construct`](http://php.net/language.oop5.decon#object.construct) 
сделан защищённым (protected), чтобы запретить создание нового объекта с помощью оператора `new`.
* Магический метод [`__clone`](http://php.net/language.oop5.cloning#object.clone) определён как частный (private),
чтобы предотвратить клонирование экземпляра класса с помощью [`clone`](http://php.net/language.oop5.cloning).
*  Магический метод  [`__wakeup`](http://php.net/language.oop5.magic#object.wakeup) определён как частный (private),
чтобы предотвратить десериализации экземпляра класса через глобальную функцию 
[`\unserialize()`](http://php.net/function.unserialize).
* Новый экземпляр создаётся с помощью 
[позднего статического связывания](http://php.net/language.oop5.late-static-bindings) в статическом методе 
`getInstance()` с ключевым словом `static`. This allows the subclassing of the class `Singleton` in the example.

Шаблон Одиночка полезен тогда, когда нужно быть уверенным, что экземпляр класса только один во всём жизненном цикле 
запроса для веб приложения. Обычно это происходит, когда имеется глобальный объект (например Configuration класс) или
общий ресурс (например очередь событий).

Вы должны быть осторожными, используя этот шаблон, поскольку по своей природе он вводит глобальное утверждение экземпляра
в приложении, понижая тем самым тестируемость. В большинстве случаев внедрение зависимостей могут (должны) 
использоваться вместо Singleton класса. Используя внедрение зависимости, означает, что мы не вводим ненужных соединений
в дизайн наших приложения, а объект, используя общий или глобальный ресурс, не требует знания конкретного класса.

* [Шаблон Одиночка на Википедии](https://ru.wikipedia.org/wiki/Singleton)

## Фронт-контролер (англ. Front Controller)

Шаблон Фронт-контроллер использует единую точку входа для приложения (например, index.php), которая обрабатывает все
запросы. Код этого шаблона отвечает за загрузку всех зависимостей, обработку и отправку запроса в браузере. 
Фронт-контроллер может быть полезным, поскольку способствует модульному коду и предоставляет центральное место,
в которое можно внедрить код для каждого запроса (например, санитарная обработка входных данных).

* [Фронт-контролер на Википедии](https://en.wikipedia.org/wiki/Front_Controller_pattern)

## Модель-представление-контроллер (англ. Model-View-Controller)

Модель-представление-контроллер (далее MVC) шаблон из то же серии, что и HMVC, MVVM. MVC позволяет разбить код
приложения на логические объекты, которые предназначены для под конкретные задачи. Модель служит как слой к доступу
данных и возвращает их в том формате, который необходим приложению. Контроллеры обрабатывают запросы,
обрабатывают данные, полученные из модели, и загружают представления, посылая в него ответ. Представления содержат
шаблоны (markup, xml и другие), которые отправляются в браузер.

MVC является наиболее распространенным архитектурным шаблоном, который используется в популярных 
[PHP фреймворков](https://github.com/codeguy/php-the-right-way/wiki/Frameworks).

Больше информации по подобным шаблонам вы можете подчеркнуть в следующих ссылках:

* [MVC](https://ru.wikipedia.org/wiki/Model-View-Controller)
* [HMVC](https://ru.wikipedia.org/wiki/HMVC)
* [MVVM](https://ru.wikipedia.org/wiki/Model-View-ViewModel)
